# 面向资源设计-概念篇

现在是`http`的时代，后端主要是提供给前端各种`api`接口，接口的设计尤为重要，当前主要以`RESTful`风格为主，在`RESTful`中必须搞明白两件事：

- 资源
- 方法

资源用来定位后台需要操作的数据，方法用来指导开发人员应该如何处理资源。`RESTful`的接口很简洁，也很直观。

现在很多后台都是微服务，采用`rpc`进行通信，以及对外提供服务，比如`grpc+protobuf`，但是最终提供给前端肯定还是`web`接口，因此有了`grpc-gateway`，开发者只需要开发一套`grpc`服务，就可以同时拥有`grpc`和`http`两种能力，服务之间使用`grpc`，对前端提供`http`，这样既可以满足前端，又可以保证内部通信的效率。

在刚接触`grpc`的时候，没有一套自己的规范，最终生成的代码接口之间也没有规律，看起来也很不好，然后就了解到`google api design`，详细讲述了谷歌内部如何设计`API`接口，目的就是设计简单，一致且易用的`API`。

因为生成的代码取决于`proto`的内容，每个人的风格不一致，就会导致生成的代码没有规律，比如一个结构是哪个方法的请求，是哪个方法的响应，又比如一个方法名代表什么功能，这就很让人头疼，为了解决这个问题，将`RESTful`引入到`grpc`的接口设计中。需要操作的对象视为资源，需要执行的操作视为方法。为什么可以这样呢，

`grpc`和`http`都是后端提供接口使用的协议而已，而后台的抽象就是对特定数据的特定操作，而`RESTful`中也正是包含着两点，因此只要有这两点信息，`grpc`也知道应该对哪个资源执行哪些操作。而且`grpc`的底层是`http2`，虽然不兼容`http1.x`，但是语义还是相同的，原来的概念依然存在，因此`grpc`是无缝衔接`RESTful`设计理念的。

上面扯了这么多都是自己的一些理解，下面是`google`官方对`REST API`的定义：

> REST API 是可单独寻址的“资源”（API 中的“名词”）的“集合”。资源通过[资源名称](https://cloud.google.com/apis/design/resource_names)被引用，并通过一组“方法”（也称为“动词”或“操作”）进行控制。
>
> REST Google API 的标准方法（也称为“REST 方法”）包括 `List`、`Get`、`Create`、`Update` 和 `Delete`。API 设计者还可以使用“自定义方法”（也称为“自定义动词”或“自定义操作”）来实现无法轻易映射到标准方法的功能（例如数据库事务）。
>
> **注意**：自定义动词并不意味着创建自定义 HTTP 动词来支持自定义方法。对基于 HTTP 的 API 而言，它们只是映射到最合适的 HTTP 动词。

资源分为两类，简单资源和集合资源，集合资源是包含相同类型资源的列表，资源有一些状态和零或多个子资源，子资源可以是简单资源也可以是集合资源。比如：

- 消息集合：`users/*/messages/*`
- 线程集合：`users/*/threads/*`
- 个人资料：`users/*/profile`
- 个人设置：`users/*/settings`

以上示例`*`代表一个具体的资源，`users`是一个集合，代表用户组。每个用户除了包含自己的资料，自己的设置信息，还包含一个消息集合和一个线程集合。

抽象之后的都是资源，但其实可以进行更高维度的抽象，还是上面的实例，其实对应的数据模型可以用以下结构描述： 

```go
type User struct {
	Messages []*message
	Threads []*thread
	Profile *profile 
	Settings *settings
}
```

也就是程序设计中的类，是一个抽象的模型，每个`user/*`都是一个具体的实例，因此可以进一步把`users`抽象为一个实体，这个实体有四种不同的资源。

资源的方法使用`http`动词使得接口语义明确，而且学习成本极低，易于接受和推广。那需要有实体的方法不，答案是不需要，实体是从更高的维度的一个抽象，最终对实体的操作还是会落实到对实体中某个资源的操作。比如：

```go
func (this *xx) CreateUser(msgs []*messages, threads []*thread, pro *profile, setting *settings) {
	this.CreateMessages(msgs)
	this.CreateThreads(threads)
	this.CreateProfile(pro)
	this.CreateSettings(setting)
}
```

创建实体的动作最终转换为四个创建资源的动作，类似的，任何对实体的操作都是直接或间接的操作资源。