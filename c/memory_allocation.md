# 内存

## 三个基本数据区

- 栈
- 堆
- 静态存储区

栈负责的是函数调用，每个函数调用都会生成一个栈帧，函数中的参数和局部变量都会储存在栈上（也可能存储在寄存器）。一个函数调用完后，它的栈帧就会被释放，那么原来栈帧上的内容将不再有效，因此函数中是无法返回一个局部变量的地址。

堆是程序中预留的一块内存空间，可以动态的申请和释放，相比于栈来说，堆存在的一个原有就是生命周期可以由程序员很好的控制，只要程序员不释放，那么内存一直是可用的，因此可以跨作用域传递。

静态存储区存储的是全局变量和静态局部变量，静态存储区的大小在编译期就确定了，在运行期间，不断的分配，声明周期为从创建到程序结束。

## 程序内存分布

首先需要知道可执行程序（经过编译，汇编，链接之后得到的）和进程的内存分布是不太一样的。可执行程序的段主要有以下几个（elf）:

- header：根据头部可以识别文件类型
- text：代码段
- bss：存放未初始化的全局变量和静态局部变量（静态区）
- data：存放已初始化的全局变量和静态局部变量（静态区）

相比可执行程序，进程没有header，但是多了以下几个段：

- heap
- stack
- rodata

## 动态内存

在一个C程序中，有栈，堆，静态存储区等等。其中栈和静态存储区都是由编译器管理的，在编译期间就决定了内存怎么分配，但是在程序运行过程中进程需要一些额外的内存，这就是需要用到堆了，可以把堆看做一个内存池，程序员可以动态的申请和释放内存。

负责申请动态内存的是`malloc`，而负责归还动态内存的是`free`。两者的函数原型如下：

```c
void* malloc(size_t size);
void free(void* pointer)
```

其中`malloc`申请内存时的单位是字节，`malloc`成功时返回程序员指定大小的一块连续内存空间，否则返回`NULL`，`free`用于将动态内存归还给堆。

有可能关于堆听到的最多的一个名词就是内存泄漏，什么是内存泄漏呢，其实就是不听的申请动态内存，而使用后并没有归还内存。所以使用动态内存的一个原则时，`malloc`和`free`应该成对的出现。

需要注意的一点是`malloc`和`free`是库函数，而不是系统调用，而C的规范知识定义了接口，而没有对其中的实现细节做限制，因此各个平台的行为可能不同，可能会导致`malloc`实际返回的内存比申请的内存要多（由于不同平台的内存管理策略的不同）。

在这里有两个经常会出现的面试题：

1. malloc(0)会出现什么行为？
2. free(NULL)会出现什么行为

第一个答案是可能会返回一个NULL，也可能返回一个非空的内存指针，但是这个内存是不可用的，只能用free释放，其实也是合理的，因为内存由两部分组成，首地址和长度，其实返回的非空内存是一个长度为0的内存，这样意味着这块内存你并没有使用权。那么它到底分配了多大的内存呢，这就回到了之前的问题，取决于不同的平台。可能的不只是内存，还有内存的一些元信息。

除了静态存储区，堆和栈为初始化的内存上都是随机值，经常会遇到申请内存后，使用`memset`填充0值，为了把两步简化为一步可以使用`calloc`。

```c
void* calloc(int num, size_t size);
```

申请`num*size`字节的内存，返回的结果和`malloc`的含义是相同的，不同的一点就在于`calloc`会将申请到的内存自动初始化为0。

有时候申请的动态内存长度不满意，可以使用`realloc`来动态的调整当前动态内存的大小，可以往大了变也可以往小了变。

```c
void* realloc(void* pointer, size_t new_size);
```

必须使用`realloc`的返回值，因为有可能调整之后的地址和原来的地址不同，这个时候原来的地址会自动被`free`，无需程序员管理，并且如果内存变大了，之前的数据会被拷贝到现在的内存上，未使用的部分是随机值，