# 时间轮

最近工作里负责重构一个定时任务的模块，而在学习的过程中延时任务的这个字眼也一直出现。两者的相同之处在于都是在某个时间点执行，不同之处在于前者是周期后者是一次性的。

文章主要介绍延时任务的调度实现，因为它是定时任务的基础，简单的说可以在注册一个延时任务时，任务中只要包含了想要执行的任务和重新注册的逻辑，那么就实现了定时任务，当然对于不同的数据结构实现来说，也可以有自己的一些优化。

延时任务中最常用的有一下几种数据结构：

- 升序链表
- 小根堆
- 时间轮

几种不同的数据结构效率也是递增的。升序链表虽然是有序的，但是链表无法使用二分查找，因为它只是逻辑上的链条，而非物理上的链条。（跳表也是链表实现的，可以使用二分查找，但是跳表是由多层有序链表组成的，而此处的链表只有一层）

基于升序链表和小根堆的实现很容易可以想到，不作为重点介绍。时间轮是第一次听到，在学习后了解到时依靠环形数组和链表实现的。结构非常的简单，而实现也是比较简洁的。

时间轮可以分为单层时间轮和层级时间轮，其中单层时间轮包含了时间轮这个结构的绝大部分思想。==从此处开始，文中出现的时间轮均代表单层时间轮==。

![image](https://raw.githubusercontent.com/Saner-Lee/pictures/master/timewheel.png)

上图所示的时间轮，实线指针指向轮子的一个槽。它以恒定的速度顺时转动，每转动一步就指向下一个槽，每次转动称为一个滴答。一个滴答的时间称为时间轮的槽间隔`si`，它时间上就是心搏时间。该时间轮共有`N`个槽，因此转一圈时间是`N*si`。每个槽指向一跳任务链表，每条链表上的任务具有相同的特征：他们的执行时间相差`N*si`的整数倍。相比于一个升序链表来说，时间轮使用哈希的思想将任务分配到很多个链表中。

对于执行时间距离当前时间非常久的任务节点，单层时间轮的处理方法是添加一个计数`cnt`属性，每次遍历链表执行任务前，如果`cnt`不为0则减1，否则就执行任务并从链表中删除。

时间轮有会有缺点，如果`si`的值不够小，那么任务真正执行时间与期望执行时间可能会相距比较大，而如果`si`的值足够小，`N`的值太小会导致任务很多的时候链表太长，效率发挥不出来，`N`的值太大的时候可能没有那么多任务，浪费了很多空间。

很显然，对时间轮而言，要提高定时精度，就要使``si``值足够小，要提高执行效率，则要求`N`值足够大。正是因为这个问题困扰着时间轮，因此产生了层级时间轮。层级时间轮中的上层用来存储第一层无法存储的任务，这样可以保证第一层的`si`足够小，又保证了每个槽上的链表的长度足够的短。在第一层时间轮一个周期后检查有无第二层时间轮，如果有，那么将槽中对应的任务下发到第一层，然后删除这些下发的任务同时指向下一个槽，此时第一层继续不停的执行任务。当第二层转过一个周期后检查有没有第三层的时间轮，如果有处理过程同第一层转完一个周期时第二层的处理。也就是说真正执行任务的是第一层时间轮，其它上层时间轮只负责存储和下发执行时间距当前时间较长的任务。

可能会有疑问，为什么上层时间轮不直接执行，而是下发到下层，最终下发到第一层的时候才会执行，因为误差，`si`是最小的单位，那么延时任务最终的执行时间都是以`si`的单位计算的。比如底层的精度是秒，第二层是分钟，那么60-120后执行的任务后存储在同一个槽中，还并未到真正的执行时间，因为下发到低层，最终由第一层去执行。

最后，附一条连接，使用go实现的一个层级时间轮。`https://github.com/Saner-Lee/timewheel.git`
