# client side cache

`cache`既可以提高性能，又可以减轻数据源的压力。在服务端是必不可少的，但是在它不仅仅在服务端可以发挥作用，在客户端也可以大展身手。

最近半年部门都在开发框架，是为了重构一块产品的`base`部分，其中最为关键的就是为了加入缓存，而且是客户端缓存。客户端缓存可以大大的节省不必要的带宽。客户端缓存的设计基本是在`http`缓存模式的基础上的进一步拓展。

客户端缓存相比于服务端缓存需要多考虑一种场景，即**客户端如何感知到缓存是否失效**。当然对于`grpc`，`websocket`或者其它支持推送机制的协议来说不是问题，但是对于`http1.x`来说是简单的`request-response`模型，并不支持推送，但是`http`缓存提供了一种很好的方案。

在命中缓存时，将资源的标识和资源的指纹发送到服务端，服务端根据资源标识取到对应资源，对取得的资源进行指纹运算，对比得到的结果和客户端发送过来的指纹：

- 如果不一致，则返回新的资源，资源标识和资源指纹
- 如果一致，则只返回Header，Header中的状态指明资源未变更，以及新的到期时间

虽然都会发起一次网络`io`，但是在资源没有更新的情况下，不需要通过`body`返回完整资源，而只返回`Header`部分告知调用者资源可用，以及资源的可用时间。在对于一些大资源或者频繁的请求接口，可以节省很多不必要的网络带宽。

在了解了客户端如何感知缓存失效后，其实客户端的缓存就掌握了一大半了，剩下的一部分就是为了提供更多的可能性给用户。接下来聊的就是`cache`的模式。

- 客户端不想使用cache
- 客户端只想在本地缓存，不允许中间节点缓存
- 客户端命中缓存，且未失效，但只是客户端未失效，不知道服务端的是否失效
  - 可以接受，直接返回
  - 不可接受，通过资源标识和资源指纹发起认证
- 客户端命中缓存，且失效
  - 可以接受，直接返回
  - 不可接受，通过资源标识和资源指纹发起认证

上面罗列了很多种场景，当然在大多数情况下，不管客户端缓存是否失效，都进行指纹验证是最稳妥的一种选择，但是开发者并不知道调用者的需求，因此，**提供可能的几种模式暴露给使用者，由使用者决定`cache`的具体行为**。

