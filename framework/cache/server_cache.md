# server side cache

服务端为就是在玩数据，基本上数据都是需要持久化的，通常都是存储在数据库中，但是数据库处理连接的能力是有限的，不能将所有请求打到数据库中，可能会造成db直接崩溃，不崩溃也可能会出现请求久久得不到响应。为了在有效的资源上提供更高的吞吐量，一个行之有效的方法就是引入缓存。

缓存有几个基本概念：

- 命中率：返回正确结果与请求缓存次数的比例
- 最大空间：缓存也是在存储介质中，不能无效的膨胀，在达到阈值后应当可以自行淘汰数据
- 淘汰策略：在达到缓存最大空间后，淘汰数据使用的淘汰策略
- 缓存失效：在资源发生变更时，应使缓存失效
- 数据一致性：保证数据库和缓存中的数据一致

前三种比较好理解，缓存失效和数据一致性不是独立的，两者是有联系的。在更新缓存时，缓存会失效也会写数据库，缓存应该何时失效，失效的时机不对，就会造成数据不一致，命中率下降。因此更新缓存也是有方法的。

有人可能会先删除缓存，再写数据库。当更新和读取并发时可能会导致数据不一致，A(更新操作)删除缓存，此时B(查询操作)没有命中缓存，于是AB都会想数据库发送请求，如果B操作先到，就会读取到旧的数据，并放到缓存中，这之后的一端时间缓存的数据一直是脏数据。

既然先让缓存失效不行，那就等待数据库操作成功后再让缓存失效吧，这种模式称为`Cache ASide`，这种模式可以有效的解决之前的问题，

当然了，可能有人对此模式有疑问，为什么不在更新数据库后直接更新缓存，而只是让缓存失效呢？也是因为可能产生脏数据，当AB两个操作先后到来时(都是更新操作)，A让缓存失效，B查看到缓存没有对应数据，两者都去请求数据库，更新完成后得到C(AB两者最终更新生效的一方)和D(AB两者中更新被覆盖的一方)都得到成功响应，由于调度的关系，C先修改了缓存，之后D修改了缓存，此时就出现了脏数据。

那么`Cache Aside`是不是就是ok的了，缓存不会出现脏数据，不是的！不过这种概率是极小的，当A(读操作)没有命中缓存时，与此同时B(更新操作)发现没有命中缓存也将请求打到数据库，这种情况可能会经常发生，但要是有脏数据，还要求A先于B到达数据库，而且B先于A从数据库返回且到达调用方，那么考虑两种情况：

- 数据库读写互斥
- 读写不互斥，使用了MVCC

通常写操作是比读操作慢的，所以在所有的前提条件下，基本上不会出现脏数据，但是对于读写不互斥，而且写操作很快，例如基于`lsm`算法的数据库，可能有问题，也可能没有问题(取决于查询的数据隐藏的多深)。

仔细想一想难道互斥的情况下就一定不会有脏数据吗，也不是，网络是不确定因素，可能B的`tcp`就会先于A的`tcp`报文到达(当然，这也意味着AB分别属于两个不同的节点)，因此网络才是是否会产生脏数据的主要原因。

这个问题也有解决的方法，大致上分为两个方向：

- 不能容忍脏数据：保证一致性
- 可以容忍脏数据：设置缓存过期时间

如果需要保证一致性，操作肯定会比较慢，如果可以容忍脏数据，通过过期时间减少脏数据存在的时长，这进一步保证了缓存的命中率。