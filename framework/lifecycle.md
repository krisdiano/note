# lifecycle

生命周期是很重要的概念，每个对象都有自己特定的生命周期，而且必定只有一次。比如`c++`中的类有构造函数和析构函数的概念：

构造函数：在创建一个对象时，做一些初始化的工作，比如设置成员变量为缺省值

析构函数：对象被即将释放时做一些收尾的工作，比如清理对象所占用的内存以及系统资源

再考虑一种场景，一个对象可能依赖其它对象，那么初始化时会调用成员变量的构造函数，自身释放时也会调用成员变量的析构函数，这里隐藏了一种包含关系，这种能力是编译器提供的，如果改为手动实现，那么生命周期就应该是提供`Hook`能力的。

上面的思考还是以对象为出发点进行思考得到的，不过生命周期这个概念是具有普遍性的，不仅仅针对于具体的对象，它可以和任何一个具体的事物联系起来，回到程序设计上来说，框架也是具有生命周期的，下面以框架为例，实现一个`lifecycle`组件（高级语言基本都有`gc`了，编译器本身就接管了变量的生命周期，因此不需要开发者关注），它至少应该满足：

1. 只能`initialize/finalize`一次
2. 提供`hook initialize/finalize`的能力
3. 查询状态

查询状态是为了制止某些错误的行为，比如在框架初始化后再使用`hook initialize`是无意义的。

按照需要的能力，`lifecycle`的大概结构如下：

```go
type lifecycle struct {
	onceIni sync.Once
	onceFin sync.Once
	
	mu sync.RWMutex
    
	iniHook []IniFunc
	finHook []FinFunc
	
    initialized bool
}
```

框架通常来说不是以对象的方式提供的，而是直接暴露函数接口，可以说框架本身就是一个单例，在一个进程中只存在一个实例，因此`lifecycle`应该也提供一个`func DefaultLifeCycle() *lifecycle`用来获取一个单例的实例，这个实例被整个进程共享，这样框架中包含的组件和可注册的插件就可以进行`hook`，这些注册的`hook function`都会在框架执行`Initialize`和`Finalize`的时候执行到。

