# Snowflake

分布式中`ID`生成什么都不依赖，纯编程实现的应该就是`snowflake`了，保证唯一，趋势递增。不过由于其中使用了时间戳，在没有持久化的情况下，如果发生宕机并且发生了时钟回退的情况下，就可能产生重复的`ID`。不过接下并没有引入持久化，而只是对`snowflake`原理的叙述，以及某一点的优化，如果读者感兴趣，可以引入一致性较强的存储中间件去实现。

snowflake的实现采用一个64位整数，只使用了其中的63位，最高位没有使用，应该是考虑到有些程序设计语言中没有无符号数。

- The ID as a whole is a 63 bit integer stored in an `int64`
- 41 bits are used to store a `timestamp` with millisecond precision, using a custom epoch.
- 10 bits are used to store a node id - a range from 0 through 1023.
- 12 bits are used to store a sequence number - a range from 0 through 4095.

```
+--------------------------------------------------------------------------+
| 1 Bit Unused | 41 Bit Timestamp |  10 Bit NodeID  |   12 Bit Sequence ID |
+--------------------------------------------------------------------------+
```

41位的时间戳时间精度达到1`ms`，10位用来配置节点信息，可以部署1024个实例，最后12位是序列号，也就是1`ms`时间一个实例做多产生4096个`ID`。经典的`snowflake`算法其实已经足够好了，但是`NodeID`含义还是不够明确，可以将其精确的划分为`MachineID`和`PID`，这样会避免使用者没有考虑单台机器部署多个实例而造成`NodeID`配置重复。`Sequence`位于最后的12位，一个实例上单位时间内的`ID`是连续的，不过在有些时候连续是不太好的，美团就会担心订单量被估计多少，因此最好将`Sequence`和`NodeID`部分需要换一下位置。改变后结构如下：

```
+------------------------------------------------------------------------------+
| 1 Bit Unused | 41 Bit Timestamp | 12 Bit Sequence ID | 5 Bit MID | 5 Bit PID |
+------------------------------------------------------------------------------+
```

`snowflake`还有一个问题就是短时间内并发量太高会阻塞等待，有些业务方式不能容忍的，此时有两种方案：

- 返回一个错误
- 增加时间片部分

两个方案各有好处，前者可以确保`ID`中的时间和系统时间是相等的，返回错误后，使用者可以决定等待还是使用其它的`ID`（`UUID`）暂时代替。后者可以确保不会阻塞，每一个请求都会立即返回一个可以使用的`ID`，但是时间片部分可能超前很多。不管使用哪种方式，都需要考虑到时间回退的问题，实现很简单，但是很必要。

或许使用者并不想使用库开发者规定的64位结构，因此在开发的过程中，要使用接口将实现抽象出来，接口主要包含每一部分的位长信息，如下：

```go
type Snowflake interface {
	BitLenTimeStamp() uint8
	BitLenSequence() uint8
	BitLenMachineID() uint8
	BitLenPID() uint8
        IsInvalid() bool			//用于检查MID和PID是否唯一
}
```

库只提供序列号自增，具体怎样解释64位信息，可以让使用者决定并实现（这就是为什么接口只需要包含位长度信息就可以了），也就是说它只需要在库的基础上提供一个解释64位结构的`API`就可以实现自己的`snowflake`算法了。那如果使用者就是想使用经典的`snowflake`算法呢，难道还需要使用者去实现接口，并提供解释64位信息的`API`？当然不用，这个需要库去做，可以让使用者直接使用经典的`snowflake`算法。

整数的好处在于大小比较效率比较高，但是`snowflake`是一种算法，并不拘泥于实现的载体，完全可以使用一个二进制流或者字符串来作为载体，这样可以使得单位时间内的并发量大大提高，而且也可以在其中加入一些其它信息，用来扩充算法。
