# goroutine池

这个礼拜工作还让自己比较满意吧，周五的时候上午完成工作后下午看了下一个go的第三方库，看过`README`后没有着手了解，而是选择了其中的`goroutine`池学习，看了一下其中的结构，选择`worker`工作时没有采用`go`中的通信的方式，而是使用了条件锁，感觉不太符合go，作者应该是使用其它语言的习惯在写go，加之`goroutine`池并不难，于是打算在看完比赛后记录一下。(`lpl`世界赛今年好惨啊，不过也从其中验证了我一直坚持的一个学习观点吧，那就是能把小事坚持下去，那么成功的概率就更大。)

`goroutine`池的整个流程并不是自己想出来的，而是基于之前学习过的`redigo`的连接池。为什么可以从连接池这里延伸出去呢，想一想，池就是为了管理其中的存储的元素，不论是连接，还是`goroutine`，两者都是池管理的元素而已。那么还可以按照之前总结的那套连接池的方法来学习。

从宏观上来说，无非就是需要其中的元素时从池中获取一个结构，使用完成后，将结构归还给池。那么简单的来讲将连接池中的`connect`换成一个`worker`结构，那么就是一个`goroutine`池了。(`worker`才是真正的执行单元)。为了使得使用起来更友好，我选择了将获取和归还结构也封装在池中，对外只提供一个接口类型的参数用于传入要执行的逻辑。对池的管理策略复用了`redigo`连接池中的管理策略，比如最大生存周期，闲置的时长等。从细节的层面来说池通过`worker`中的`Job channel`来传递要执行的逻辑(`Job`就是要执行的逻辑的接口类型)，在执行完毕后`worker`通过持有自己的池的通道传递一个信号，池并不需要一直等待这个信号，只需要在需要`worker`时读取是否有信号即可。

如果对`redigo`的连接池还没有太懂，那么可以去看一下我之前的文章，最后给出一个自己grpool的实现。地址是https://github.com/Saner-Lee/grpool.git

