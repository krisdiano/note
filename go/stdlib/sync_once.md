# Once

sync.Once是一个开箱即用的结构。它只有一个Do方法，在官方文档中也很清楚的解释了它的作用，Do方法并不是对传入的每个函数对象只执行一次，而是说Do只能真正的执行一次。

这种类型实例的Do方法可以多次调用，但是真正发生作用的次数只有一次。下面来看看它的实现。

```go
type Once struct {
	m    Mutex
	done uint32
}

func (o *Once) Do(f func()) {
	if atomic.LoadUint32(&o.done) == 1 {
		return
	}
	// Slow-path.
	o.m.Lock()
	defer o.m.Unlock()
	if o.done == 0 {
		defer atomic.StoreUint32(&o.done, 1)
		f()
	}
}

```

内部有两个成员：

- 计数器
- 锁

这个计数器的值只可能是0或1，首先利用原子操作判断计数器的值是不是1，如果条件成立代表Do方法已经执行过了，直接就返回了，这就是上述所说的只能真正发生一次。

既然原子操作已经判断了为什么还需要锁呢，这是考虑到并发的场景下，如果一个该类型的一个实例在两个线程中同时执行Do方法，两个线程可能得到的计数器的值都是0，这样就违背了这个函数的功能。所以用锁来进行第二次的检查，这样面临上述问题时，其中一个线程执行完后计数器的值变为了1，第二个线程就会在第二次检查时发现函数已经执行过了，自己编解锁退出了。

那么直接用锁不用原子操作可不可以，当然可以！那么为什么要有原子操作？其实这是为了快速试错，因为原子操作相对于锁来说性能是很高的。