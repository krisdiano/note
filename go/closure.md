# 闭包的实现

what is 闭包，这是个什么鬼，对于以前是学C的人根本不知道，搜索一番好像最多的都是`Javascript`的概念，现在主要以`golang`为主，就拿`golang`来说，它的闭包=匿名函数+上下文变量。拿例子说吧。

```go
package main

import "fmt"

func closure() func() {
	i := 8 
	j := 16
	k := 32

	return func() {
		fmt.Println(i, j, k)
		i++
		j++
		k++
	}
}

func main() {
	fn := closure()

	fn()
	fn()
}
```

`closure`中的匿名函数作为返回值，而且这个匿名函数内部引用了closure的变量。在C中，函数的变量是在栈上的，函数调用完毕，栈帧消失，这样的现象肯定不会发生，不过这是`golang`，这里不报错就是因为内存管理机制和形成了闭包。

## 验证

    go build -gcflags "-l -N -m" -o main main.go 
    
    ./main.go:11:15: &i escapes to heap
    ./main.go:6:2: moved to heap: i
    ./main.go:11:18: &j escapes to heap
    ./main.go:7:2: moved to heap: j
    ./main.go:11:21: &k escapes to heap
    ./main.go:8:2: moved to heap: k

编译一下发现输出信息中有这么几条语句，到这里，编译器自己都把上面问题的答案给出来了。就是逃逸到堆上了。逃逸是在学习`golang`时接触的概念，意思就是编译器会自己分析数据的生命周期，然后确定放到栈上还是别的地方存储。不知道这个概念的话，你看到下面的代码可能会问候一下写代码的人。

```go
func test() *int {
    var i int
    ...
    
    return &i
}
```

上述的代码在C/C++中是绝对不允许的。接着闭包的话题说，现在已经知道它是存储在堆上了，但是编译器是怎么寻址上下文变量的呢。换句话说，存储在堆上的变量，它的地址存储在哪呢？

可以看到闭包用到了匿名函数作为返回值，而匿名函数作为返回值时返回的是一个二级指针，相比于匿名函数直接调用的形式多了两次寻址过程，这种没有什么好处的事编译器怎么可能会做呢。所以匿名函数作为返回值时返回的二级指针就是特意用来处理闭包的。那么二级指针和闭包怎么联系起来呢？还是先看一下匿名函数的地址

```shell
nm main | grep "main.closure"

0000000000484b60 T main.closure.func1
```

为了验证三个变量的地址存储在哪里，必须先知道三个变量的地址。

```shell
gdb main
break 19
run
step
next 4
info locals

&i = 0xc0000140a8
&j = 0xc0000140c0
&k = 0xc0000140c8

print /x $rbp
0xc000030768

print /x $rsp
0xc000030738
```

上面的部分除了拿到了三个变量的地址，还证明了两点，首先当前环境下的栈是向下生长的。其次就是通过地址的比对发现确实不在当前的栈帧上(ps:白说，上面都说逃逸到堆上了)。

既然都已经猜测了这几个地址和返回的二级指针有关，现在还没扯上关系呢，所以返回主函数，继续验证。

    finish
    next
    info locals
    
    fn = {void ()} 0xc000030780
    
    x /1xg 0xc000030780
    
    0xc000030780:	0x000000c00000a060
    
    x /4xg 0x000000c00000a060
    
    0xc00000a060:	0x0000000000484b60	0x000000c0000140a8
    0xc00000a070:	0x000000c0000140c0	0x000000c0000140c8

匿名函数那一篇中当时最后用的是`x /1xg addr`，当时只看到了匿名函数的地址，现在多查看一些内存，就会发现了。对比一下得到的数据吧。


| 地址           | 值                                   |
| -------------- | ------------------------------------ |
| `0xc00000a060` | `0x0000484b60`(`main.closure.func1`) |
| `0xc00000a068` | `0xc0000140a8`(`&i`)                 |
| `0xc00000a070` | `0xc0000140c0`(`&j`)                 |
| `0xc00000a078` | `0xc0000140c8`(`&k`)                 |

结果有了，发现引用的上下文变量的地址就跟在保存匿名函数地址之后的地方。这验证了开篇就说的`golang`中的闭包=匿名函数+上下文变量。

## 总结
闭包依托匿名函数作为返回值的形式实现，这也导致了匿名函数作为返回值时，尽管它没有形成闭包，但还是会导致调用的效率降低。


    
