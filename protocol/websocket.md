# websocket

起初是由于同事在业务中使用了`websocket`，加之以前听说过这个概念，但是一直没有去了解，趁着闲暇时间看了一下协议。

如今的架构基本上都是`cs`和`bs`，就拿比较常见的`http`来说，真正在完成计算任务的是一般都是后端，一些简单的任务可以很快返回，客户端会立即收到响应，但是还会有一些比较复杂且耗时的任务，如果服务端需要处理很久，客户端就会一直等待，不能做任何其它的事情，这也真是`HTTP1.1`的线头阻塞的问题，即使`pipeline`机制可以把多个请求放在同一个`tcp`连接上，并且在发送的过程中不需要等待服务器最前一个请求的响应，但是要求客户端还是要按照发送的顺序来接收响应，相当于响应被阻塞了，问题并没有解决，也就是为什么浏览器都不支持这一特性的原因。

能脱颖而出的一点应该就是服务端推送了。为什么服务端推送这么重要呢？因为客户端可以在等待的这段时间去做别的事情，为了达到这个目的，就需要知道任务什么时候完成了，解决方案有两种：

- 轮询
- 服务端推送

两者的效率肯定是后者强， 相当于是一种事件通知机制。除了这一点之外，`websocket`能流行起来的原因在于它是兼容`http`的。为什么这么说呢？其实`websocket`是不仅局限于`http`，它支持任何基于`tcp`的应用层协议，只不过协议的升级依赖于`http`（毕竟当前对用户来说最方便的就是浏览器），了解之后觉得它又倒退为`tcp`了。

为什么`HTTP1.1`不支持服务端推送，`websocket`却可以支持呢？两者都是基于`tcp`的，不同的是应用层的限制，是`HTTP1.1`约束了如何发送请求和接收响应，因此可以说是自己束缚了自己的手脚，而`websocket`确没有此类约束。

```
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

协议内容很简单，还是说一下各部分的意义吧：

- `FIN`：一个请求或响应被划分为很多帧，标志后续是否还有此消息的帧
- `RSV`：保留位，置0（成熟的工业性协议都会预留一些）
- `opcode`：帧的类型
- `MASK`：是否有掩码
- `Payload len`:长度
- `Maskiing-key`：如果`MASK`为`true`，这里代表掩码
- `Payload Data`：数据（如果`MASK`为`true`，数据是被和掩码运算过的）

帧，可以是消息帧，也可以是控制帧，对于消息帧还可以细分为文本帧，二进制帧，以及当前消息是否完毕（`FIN`和`opcode`结合才能判断一个消息是否传输完毕），对于控制帧可以细分为心跳请求和心跳响应。两者帧类型都有一些保留发范围数值，用于以后扩展。

到这里忽略了一个最重要的一点，就是协议升级，要使用`websocket` 协议必须提前发送一个使用`http`请求和响应进行一次握手，握手成功代表切换了协议。

升级为`websokcet`协议后，客户端和服务端就可以互相发送消息了，只要双方按照消息的语义进行工作就可以了，其实此时就已经退化成`tcp`协议了，没有了`http`的限制。

