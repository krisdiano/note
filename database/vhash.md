# 提供差量读的集合存储

程序的本质是早操作数据，无非是数据的变更，数据的迁移。为了方便的操作数据，程序都会提供容器。比如：`struct`，`array`，`hash`和`set`，`struct`可以将不同类型的数据集中在一起，`array`是将相同数据类型的数据集中在一起，两者主要是存储数据，而`hash`和`set`在除了基础的存储还有查询的语义。对于很多业务场景来说，`hash`和`set`尤其重要。

`hash`和`set`本质的结构是一样的，因此以下讨论主要针对于`set`来说。本身这种结构是很简单的，在数据库中的存储也很简单，但是本文是要实现基于版本的提供差量读的`set`，这对于大数据量的获取操作情况下是很有必要的，可以节省很大的带宽。

在存储的时候提供的是一个三元组-`(key, version, deleted)`，在这个三元组中要求version是递增的。下面的version用时间戳标识，下面举例说明如何操作：

显示有三个PUT操作：put(1)，put(2)，put(3)

| key  | version | deleted |
| ---- | ------- | ------- |
| 1    | t1      | 0       |
| 2    | t2      | 0       |
| 3    | t3      | 0       |

然后操作是：delete(2)，put(4)

| key  | version | deleted |
| ---- | ------- | ------- |
| 1    | t1      | 0       |
| 2    | t4      | 1       |
| 3    | t3      | 0       |
| 4    | t5      | 0       |

然后有操作：delete(1)，put(1)

| key  | version | deleted |
| ---- | ------- | ------- |
| 1    | t6      | 1       |
| 2    | t4      | 1       |
| 3    | t3      | 0       |
| 4    | t5      | 0       |

| key  | version | deleted |
| ---- | ------- | ------- |
| 1    | t7      | 0       |
| 2    | t4      | 1       |
| 3    | t3      | 0       |
| 4    | t5      | 0       |

调用者读取集合的时候需要提供版本参数，如果版本为对应类型的零值，代表此时本地无任何数据，需要获取全量，此时中需要筛选出`deleted`不为1的数据项返回即可，对于以上事例执行操作：get(0)

| key  | version | deleted |
| ---- | ------- | ------- |
| 1    | t1      | 0       |
| 3    | t3      | 0       |
| 4    | t5      | 0       |

此时获取到数据，并且数据项的最大版本是t5，此后获取集合数据时，版本参数使用t5。为了演示客户端如何合并数据假设，此时调用者本地最大的版本是t3，此时执行操作：get(3)

| key  | version | deleted |
| ---- | ------- | ------- |
| 1    | t7      | 0       |
| 2    | t4      | 1       |
| 4    | t5      | 0       |

根据返回的结果和本地已有的数据合并即可得到最新的数据，这个例子也可以看到，返回的数据有冗余的数据(key 1这对于hash来说，可能就不是冗余的，因为可能是在删除后更新了值的部分，或者直接更新了值得部分)，这个需要调用者根据合并过程中使用的数据结构判断是否需要过滤，这个是细节，这里调用者只要知道有冗余数据即可。